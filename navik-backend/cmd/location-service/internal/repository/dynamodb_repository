// package repository

// import (
// "context"
// "fmt"
// "log"
// "math"
// "sync"
// "time"

// "github.com/aws/aws-sdk-go/aws"
// "github.com/aws/aws-sdk-go/service/dynamodb"
// "github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"

// "location-service/internal/model"
// )

// type LocationRepository interface {
// Store(ctx context.Context, loc model.LocationDB) error
// }

// type DynamoDBLocationRepository struct {
// ddb *dynamodb.DynamoDB
// tableName string
// batchSize int
// batchInterval time.Duration
// batchMutex sync.Mutex
// itemBatches map[string][]*dynamodb.WriteRequest
// batchTimers map[string]*time.Timer
// }

// func NewDynamoDBLocationRepository(ddb *dynamodb.DynamoDB, tableName string) *DynamoDBLocationRepository {
// return &DynamoDBLocationRepository{
// ddb: ddb,
// tableName: tableName,
// batchSize: 25,
// batchInterval: 1 * time.Second,
// itemBatches: make(map[string][]*dynamodb.WriteRequest),
// batchTimers: make(map[string]*time.Timer),
// }
// }

// // Store saves a LocationDB record by marshalling it and adding it to a batch.
// func (r *DynamoDBLocationRepository) Store(ctx context.Context, loc model.LocationDB) error {
// item, err := dynamodbattribute.MarshalMap(loc)
// if err != nil {
// return fmt.Errorf("failed to marshal location: %w", err)
// }

// request := &dynamodb.WriteRequest{
// 	PutRequest: &dynamodb.PutRequest{
// 		Item: item,
// 	},
// }

// r.batchMutex.Lock()
// defer r.batchMutex.Unlock()

// r.itemBatches[r.tableName] = append(r.itemBatches[r.tableName], request)

// // If this is the first item in the batch, start a timer to flush it.
// if len(r.itemBatches[r.tableName]) == 1 {
// 	if timer, exists := r.batchTimers[r.tableName]; exists {
// 		timer.Stop()
// 	}
// 	r.batchTimers[r.tableName] = time.AfterFunc(r.batchInterval, func() {
// 		r.flushBatch(r.tableName)
// 	})
// }

// // If the batch size is reached, flush immediately.
// if len(r.itemBatches[r.tableName]) >= r.batchSize {
// 	go r.flushBatch(r.tableName)
// }

// return nil
// }

// // flushBatch sends the pending batch of write requests to DynamoDB.
// func (r *DynamoDBLocationRepository) flushBatch(tableName string) {
// r.batchMutex.Lock()
// if len(r.itemBatches[tableName]) == 0 {
// r.batchMutex.Unlock()
// return
// }

// batch := r.itemBatches[tableName]
// r.itemBatches[tableName] = nil
// if timer, exists := r.batchTimers[tableName]; exists {
// 	timer.Stop()
// 	delete(r.batchTimers, tableName)
// }
// r.batchMutex.Unlock()

// log.Printf("Flushing batch of %d items to DynamoDB", len(batch))

// // Write items in chunks of 25 (DynamoDB batch limit).
// for i := 0; i < len(batch); i += 25 {
// 	end := i + 25
// 	if end > len(batch) {
// 		end = len(batch)
// 	}
// 	chunk := batch[i:end]
// 	requestItems := map[string][]*dynamodb.WriteRequest{
// 		tableName: chunk,
// 	}

// 	maxRetries := 10
// 	for attempt := 1; attempt <= maxRetries; attempt++ {
// 		out, err := r.ddb.BatchWriteItem(&dynamodb.BatchWriteItemInput{
// 			RequestItems: requestItems,
// 		})
// 		if err == nil && (out.UnprocessedItems == nil || len(out.UnprocessedItems) == 0) {
// 			break
// 		}

// 		if err != nil {
// 			log.Printf("Batch write error (attempt %d/%d): %v", attempt, maxRetries, err)
// 		} else if len(out.UnprocessedItems) > 0 {
// 			log.Printf("%d items unprocessed in batch, retrying", len(out.UnprocessedItems[tableName]))
// 			requestItems = out.UnprocessedItems
// 		}

// 		if attempt == maxRetries {
// 			log.Printf("Failed to flush batch after %d attempts", maxRetries)
// 			break
// 		}

// 		time.Sleep(time.Duration(math.Pow(2, float64(attempt))) * 200 * time.Millisecond)
// 	}
// }
// }